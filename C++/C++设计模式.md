# C++设计模式

软件设计复杂的根本原因：**变化**（客户需求的变化，技术平台的变化，开发团队的变化...）

### 软件设计的目标

什么是好的软件？软件设计的金科玉律：**复用**

变化是复用的天敌，面向对象设计最大的优势在于：**抵御变化**！

### 面向对象设计原则

现代软件设计的特征是“需求频繁变化”，**设计模式的要点是“寻找变化点，然后在变化点处应用设计模式，从而来更好的应对需求的变化”，什么时候，什么地点应用设计模式是关键的**

- **依赖倒置原则**

  - 高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）

  - 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖与抽象（稳定）

- **开放封闭原则**
  - 对扩展开放，对更改封闭
  - 类模块应该是可扩展的，但是不可修改

- **单一职责原则**

  - 一个类应该仅有一个引起它变化的原因
  - 变化的方向隐含着类的责任

- **liskov替换原则**
  - 子类必须能够替换它们的基类（IS-A）
- **接口隔离原则**
  - **不应该强迫客户程序依赖它们不用的方法**（接口public/private/protected属性的注意）
  - 接口应该小而完备
- **优先使用对象组合，而不是类继承**
  - 继承在某种程度上破坏了封装性，子类父类耦合度高
  - 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低
- **封装变化点**
  - 使用封装来创建对象之间的分界层，让设计者可以在分界的一侧进行修改，而不会对另一侧产生不良影响，从而实现层次间的松耦合
- **针对接口编程，而不是针对实现编程**
  - 减少系统中的各部分的依赖关系，从而实现“高内聚，低耦合”的类型设计方案
  - 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口

### 重构关键技法

- 静态 -》动态
- 早绑定 -》晚绑定
- 继承 -》 组合
- 编译时依赖 -》 运行时依赖
- 紧耦合 -》松耦合

### “组件协作”类模式

“组件协作”通过晚期绑定，来实现框架与应用之间的松耦合，是二者之间协作时常用的模式

典型模式包括：

1. Template Method
2. Strategy
3. Observer/Event

**一、Template Method**

定义一个操作中的算法的骨架（稳定），而将一些步骤延迟（变化）到子类中，Template Method使得子类可以不改变一个算法的结构即可重定义（override 重写）该算法的某些特定步骤，样例代码如下：

```c++
//程序库开发人员
class Library {
public:
    void Run() {
        step1();
        if (step2()) { //支持变化，-》虚函数的多态调用
            step3();
        }
        step4();  // 支持变化-》虚函数的多态调用
        step5();
    }
    virtual ~Library(){}
protected:
    void step1() {  //稳定
    }
    void step3() {  //稳定
    }
    void step5() {
    }
    virtual bool step2() =0;    //变化
    virtual void step4() =0;    //变化
};

//应用程序开发人员
class Application : public Library {
protected:
    virtual bool step2() {
        //子类重写实现
    }
    virtual void step4() {
        //子类重写实现
    }
};

int main() {
    Library* pLib = new Application();
    pLib -> Run();

    delete pLib;
}

```

Template Method是一种非常基础性的设计模式，在很多面向对象系统中有着大量的应用，它用最简洁的机制（**虚函数的多态**）为很多应用程序框架提供了灵活的扩展点，“**不要调用我，让我来调用你**”（站在libarary的角度）的反向控制结构是template method的典型应用；

二、**Strategy** (**策略模式**)

定义：定义一系列算法，把他们一个一个封装起来，并且使得他们可以互相替换（变化），该模式使得算法可独立于使用它的客户端程序（稳定）而变化（扩展，子类化）

































