# C++设计模式

软件设计复杂的根本原因：**变化**（客户需求的变化，技术平台的变化，开发团队的变化...）

### 软件设计的目标

什么是好的软件？软件设计的金科玉律：**复用**

变化是复用的天敌，面向对象设计最大的优势在于：**抵御变化**！

### 面向对象设计原则

现代软件设计的特征是“需求频繁变化”，**设计模式的要点是“寻找变化点，然后在变化点处应用设计模式，从而来更好的应对需求的变化”，什么时候，什么地点应用设计模式是关键的**

- **依赖倒置原则**

  - 高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）

  - 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖与抽象（稳定）

- **开放封闭原则**
  - 对扩展开放，对更改封闭
  - 类模块应该是可扩展的，但是不可修改

- **单一职责原则**

  - 一个类应该仅有一个引起它变化的原因
  - 变化的方向隐含着类的责任

- **liskov替换原则**
  - 子类必须能够替换它们的基类（IS-A）
- **接口隔离原则**
  - **不应该强迫客户程序依赖它们不用的方法**（接口public/private/protected属性的注意）
  - 接口应该小而完备
- **优先使用对象组合，而不是类继承**
  - 继承在某种程度上破坏了封装性，子类父类耦合度高
  - 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低
- **封装变化点**
  - 使用封装来创建对象之间的分界层，让设计者可以在分界的一侧进行修改，而不会对另一侧产生不良影响，从而实现层次间的松耦合
- **针对接口编程，而不是针对实现编程**
  - 减少系统中的各部分的依赖关系，从而实现“高内聚，低耦合”的类型设计方案
  - 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口

### 重构关键技法

- 静态 -》动态
- 早绑定 -》晚绑定
- 继承 -》 组合
- 编译时依赖 -》 运行时依赖
- 紧耦合 -》松耦合

### “组件协作”类模式

“组件协作”通过晚期绑定，来实现框架与应用之间的松耦合，是二者之间协作时常用的模式

典型模式包括：

1. Template Method
2. Strategy
3. Observer/Event

**一、Template Method**

定义一个操作中的算法的骨架（稳定），而将一些步骤延迟（变化）到子类中，Template Method使得子类可以不改变一个算法的结构即可重定义（override 重写）该算法的某些特定步骤，样例代码如下：

```c++
//程序库开发人员
class Library {
public:
    void Run() {
        step1();
        if (step2()) { //支持变化，-》虚函数的多态调用
            step3();
        }
        step4();  // 支持变化-》虚函数的多态调用
        step5();
    }
    virtual ~Library(){}
protected:
    void step1() {  //稳定
    }
    void step3() {  //稳定
    }
    void step5() {
    }
    virtual bool step2() =0;    //变化
    virtual void step4() =0;    //变化
};

//应用程序开发人员
class Application : public Library {
protected:
    virtual bool step2() {
        //子类重写实现
    }
    virtual void step4() {
        //子类重写实现
    }
};

int main() {
    Library* pLib = new Application();
    pLib -> Run();

    delete pLib;
}

```

Template Method是一种非常基础性的设计模式，在很多面向对象系统中有着大量的应用，它用最简洁的机制（**虚函数的多态**）为很多应用程序框架提供了灵活的扩展点，“**不要调用我，让我来调用你**”（站在libarary的角度）的反向控制结构是template method的典型应用；

二、**Strategy** (**策略模式**)

定义：定义一系列算法，把他们一个一个封装起来，并且使得他们可以互相替换（变化），**该模式使得算法可独立于使用它的客户端程序（稳定）而变化（扩展，子类化）**，例子代码如下：

```c++
#include <iostream>

using namespace std;

enum TaxBase {
    CN_Tax,
    US_Tax,
    DE_Tax
};

class SalesOrder {
public:
    double CalculateTax() {
        //...
        if (tax == CN_Tax) {
            //CN....
        }
        else if (tax == US_Tax) {
            //US...
        }
        else if (tax == DE_Tax) {
            //DE...
        }
    }
private:
    TaxBase tax;
};

```

考虑如上税率计算问题，对于不同国家的税率计算，我们直观上可能会写出如上代码，但是当需要增加国家的税率计算时，需要修改CalculateTax()方法和TaxBase，代码复用性差；

Strategy模式的解决方案如下：

```c++

```



**strategy模式要点总结：**

1. strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间切换；
2. strategy模式提供了用if else条件判断的另外一种选择，消除条件判断语句就是在解耦合，含有很多条件判断语句的代码通常都需要strategy模式；
3. 如果strategy对象没有实例变量，那么各个上下文可以共享同一个strategy对象，从而节省对象开销；

三、**观察者模式**

- 在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”－－一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使得软件不能很好的抵御变化。

- 使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系，从而实现软件体系结构的松耦合。



































