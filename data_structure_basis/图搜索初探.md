# 图搜索初探

###先导：

- 递归：递 + 归
- 递归奥义：复制自己
- 递归框架：

```C++
int robot(int x,int y)
    if (边界条件)        //什么时候不用造了，自己就能干完
        return value;
	int a = robot(x1,y1);   //造一个小弟帮自己干活
	int b = robot(x2,y2);   //再造一个小弟帮自己干活
	return a + b;           //自己要做的就是把别人的成果拿来
```

leetcode 78

### 图

- 图是描述世间万物关系的一种方式

- 节点+边

- 隐士图

  状态（节点）不确定（明显）

  关系（边）不确定（明显）

  **如何确定状态和关系**（重点）

- **图搜索**

  1. 深度优先搜索（DFS）
  2. 广度优先搜索（BFS）

- 隐式图搜索：N皇后问题、骑士游历问题、八数码等

- 遍历（搜索）定义：按某种顺序访问图中所有的节点

  顺序：

  1. 深度优先（优先往深处走）
  2. 广度优先（优先走最近的）

  时间复杂度：O（n+m）

- 两种遍历方式的数据结构

  1. 栈（递归，深度优先）
  2. 队列（广度优先）（类似于树的层次遍历）
  3. 广度优先找出的路径，经过节点数最少

- 深度优先（伪代码）

```C++
void DFS(int v)
    visited[v] = true;
	for (v的每一个邻接点w)
        if (!visited[w])
            DFS(w);
```

### N皇后问题

在N*N的棋盘上摆放N个皇后，使得任意两个皇后都不能处于同一行、同一列或同一斜线上

- 回溯法（暴力搜索）：本质就是深度优先（隐式图搜索）

思路：

- 定义状态和关系:皇后棋子每次放一个进去后看做一个状态，关系就是这次放皇后和下次再放皇后之间看成一个关系
- 时间复杂度N的N次方（状态空间）
- 剪枝（确定性）

TODO: leetcode 51

### 骑士游历问题

国际象棋棋盘上，有一个骑士（马）从左下角出发，是否能不重复的遍历每一个格子

思路：

- 没啥好的方法，考虑暴力
- 定义状态、关系
- 除了剪枝，还有什么办法？（利用位操作记录已经走的位置）